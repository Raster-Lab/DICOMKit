//
// Segmentation.swift
// DICOMKit
//
// Created by DICOMKit on 2026-02-05.
// Copyright Â© 2026 DICOMKit. All rights reserved.
//

import Foundation
import DICOMCore

/// DICOM Segmentation IOD
///
/// A Segmentation object contains labeled image regions representing anatomical structures,
/// pathological regions, or other areas of interest. Segmentations can be binary (presence/absence)
/// or fractional (probability values) and are commonly generated by AI/ML algorithms or manual
/// annotation tools.
///
/// Reference: PS3.3 A.51 - Segmentation IOD
/// Reference: PS3.3 C.8.20 - Segmentation Modules
public struct Segmentation: Sendable {
    
    // MARK: - Segmentation Identification
    
    /// SOP Instance UID
    public let sopInstanceUID: String
    
    /// SOP Class UID (should be Segmentation Storage: 1.2.840.10008.5.1.4.1.1.66.4)
    public let sopClassUID: String
    
    /// Series Instance UID
    public let seriesInstanceUID: String
    
    /// Study Instance UID
    public let studyInstanceUID: String
    
    /// Instance Number
    public let instanceNumber: Int?
    
    /// Content Label - a label that identifies the content
    public let contentLabel: String?
    
    /// Content Description - human-readable description
    public let contentDescription: String?
    
    /// Content Creator's Name
    public let contentCreatorName: DICOMPersonName?
    
    /// Content Date
    public let contentDate: DICOMDate?
    
    /// Content Time
    public let contentTime: DICOMTime?
    
    // MARK: - Segmentation Type and Properties
    
    /// Type of segmentation (BINARY or FRACTIONAL)
    public let segmentationType: SegmentationType
    
    /// Segmentation fractional type (only for FRACTIONAL)
    public let segmentationFractionalType: SegmentationFractionalType?
    
    /// Maximum fractional value (only for FRACTIONAL)
    public let maxFractionalValue: Int?
    
    /// Number of segments
    public let numberOfSegments: Int
    
    /// Segment sequence - definitions of all segments
    public let segments: [Segment]
    
    // MARK: - Image Reference
    
    /// Frame of Reference UID
    public let frameOfReferenceUID: String?
    
    /// Dimension Organization UID
    public let dimensionOrganizationUID: String?
    
    /// Referenced Series Sequence
    public let referencedSeries: [SegmentationReferencedSeries]
    
    // MARK: - Pixel Data Properties
    
    /// Number of frames
    public let numberOfFrames: Int
    
    /// Rows
    public let rows: Int
    
    /// Columns
    public let columns: Int
    
    /// Bits Allocated
    public let bitsAllocated: Int
    
    /// Bits Stored
    public let bitsStored: Int
    
    /// High Bit
    public let highBit: Int
    
    /// Samples Per Pixel
    public let samplesPerPixel: Int
    
    /// Photometric Interpretation
    public let photometricInterpretation: String
    
    /// Pixel Representation (0 = unsigned, 1 = signed)
    public let pixelRepresentation: Int
    
    // MARK: - Functional Groups
    
    /// Shared Functional Groups Sequence
    public let sharedFunctionalGroups: FunctionalGroup?
    
    /// Per-Frame Functional Groups Sequence
    public let perFrameFunctionalGroups: [FunctionalGroup]
    
    // MARK: - Initialization
    
    /// Initialize a Segmentation
    public init(
        sopInstanceUID: String,
        sopClassUID: String = "1.2.840.10008.5.1.4.1.1.66.4",
        seriesInstanceUID: String,
        studyInstanceUID: String,
        instanceNumber: Int? = nil,
        contentLabel: String? = nil,
        contentDescription: String? = nil,
        contentCreatorName: DICOMPersonName? = nil,
        contentDate: DICOMDate? = nil,
        contentTime: DICOMTime? = nil,
        segmentationType: SegmentationType,
        segmentationFractionalType: SegmentationFractionalType? = nil,
        maxFractionalValue: Int? = nil,
        numberOfSegments: Int,
        segments: [Segment],
        frameOfReferenceUID: String? = nil,
        dimensionOrganizationUID: String? = nil,
        referencedSeries: [SegmentationReferencedSeries] = [],
        numberOfFrames: Int,
        rows: Int,
        columns: Int,
        bitsAllocated: Int,
        bitsStored: Int,
        highBit: Int,
        samplesPerPixel: Int = 1,
        photometricInterpretation: String = "MONOCHROME2",
        pixelRepresentation: Int = 0,
        sharedFunctionalGroups: FunctionalGroup? = nil,
        perFrameFunctionalGroups: [FunctionalGroup] = []
    ) {
        self.sopInstanceUID = sopInstanceUID
        self.sopClassUID = sopClassUID
        self.seriesInstanceUID = seriesInstanceUID
        self.studyInstanceUID = studyInstanceUID
        self.instanceNumber = instanceNumber
        self.contentLabel = contentLabel
        self.contentDescription = contentDescription
        self.contentCreatorName = contentCreatorName
        self.contentDate = contentDate
        self.contentTime = contentTime
        self.segmentationType = segmentationType
        self.segmentationFractionalType = segmentationFractionalType
        self.maxFractionalValue = maxFractionalValue
        self.numberOfSegments = numberOfSegments
        self.segments = segments
        self.frameOfReferenceUID = frameOfReferenceUID
        self.dimensionOrganizationUID = dimensionOrganizationUID
        self.referencedSeries = referencedSeries
        self.numberOfFrames = numberOfFrames
        self.rows = rows
        self.columns = columns
        self.bitsAllocated = bitsAllocated
        self.bitsStored = bitsStored
        self.highBit = highBit
        self.samplesPerPixel = samplesPerPixel
        self.photometricInterpretation = photometricInterpretation
        self.pixelRepresentation = pixelRepresentation
        self.sharedFunctionalGroups = sharedFunctionalGroups
        self.perFrameFunctionalGroups = perFrameFunctionalGroups
    }
}

// MARK: - SegmentationType

/// Type of segmentation encoding
///
/// Reference: PS3.3 C.8.20.2 - Segmentation Image Module
public enum SegmentationType: String, Sendable, Codable {
    /// Binary segmentation (1 bit per pixel, presence/absence)
    case binary = "BINARY"
    
    /// Fractional segmentation (8 or 16 bits per pixel, probability values)
    case fractional = "FRACTIONAL"
}

// MARK: - SegmentationFractionalType

/// Type of fractional segmentation values
///
/// Reference: PS3.3 C.8.20.2 - Segmentation Image Module
public enum SegmentationFractionalType: String, Sendable, Codable {
    /// Probability values (0.0 to 1.0)
    case probability = "PROBABILITY"
    
    /// Occupancy values (fraction of voxel occupied, 0.0 to 1.0)
    case occupancy = "OCCUPANCY"
}

// MARK: - Segment

/// Segment Definition
///
/// Defines a single segment with its identification, category, and visual properties.
///
/// Reference: PS3.3 C.8.20.4 - Segment Description Macro
public struct Segment: Sendable, Hashable, Identifiable {
    
    /// Segment number (unique within the segmentation, starts from 1)
    public let segmentNumber: Int
    
    /// Segment Label - human-readable name
    public let segmentLabel: String
    
    /// Segment Description
    public let segmentDescription: String?
    
    /// Segmentation Algorithm Type
    public let segmentAlgorithmType: SegmentAlgorithmType?
    
    /// Segmentation Algorithm Name
    public let segmentAlgorithmName: String?
    
    /// Segment Category (e.g., Tissue, Organ, Lesion)
    public let category: CodedConcept?
    
    /// Segment Type (e.g., Liver, Tumor, Background)
    public let type: CodedConcept?
    
    /// Anatomic Region Sequence
    public let anatomicRegion: CodedConcept?
    
    /// Anatomic Region Modifier Sequence
    public let anatomicRegionModifier: CodedConcept?
    
    /// Recommended Display Color (RGB, CIELab values 0-65535)
    public let recommendedDisplayCIELabValue: CIELabColor?
    
    /// Tracking ID for longitudinal studies
    public let trackingID: String?
    
    /// Tracking UID for globally unique identification
    public let trackingUID: String?
    
    /// Identifiable conformance
    public var id: Int { segmentNumber }
    
    /// Initialize a Segment
    public init(
        segmentNumber: Int,
        segmentLabel: String,
        segmentDescription: String? = nil,
        segmentAlgorithmType: SegmentAlgorithmType? = nil,
        segmentAlgorithmName: String? = nil,
        category: CodedConcept? = nil,
        type: CodedConcept? = nil,
        anatomicRegion: CodedConcept? = nil,
        anatomicRegionModifier: CodedConcept? = nil,
        recommendedDisplayCIELabValue: CIELabColor? = nil,
        trackingID: String? = nil,
        trackingUID: String? = nil
    ) {
        self.segmentNumber = segmentNumber
        self.segmentLabel = segmentLabel
        self.segmentDescription = segmentDescription
        self.segmentAlgorithmType = segmentAlgorithmType
        self.segmentAlgorithmName = segmentAlgorithmName
        self.category = category
        self.type = type
        self.anatomicRegion = anatomicRegion
        self.anatomicRegionModifier = anatomicRegionModifier
        self.recommendedDisplayCIELabValue = recommendedDisplayCIELabValue
        self.trackingID = trackingID
        self.trackingUID = trackingUID
    }
}

// MARK: - SegmentAlgorithmType

/// Type of algorithm used to generate the segment
///
/// Reference: PS3.3 C.8.20.4 - Segment Description Macro
public enum SegmentAlgorithmType: String, Sendable, Codable {
    /// Automatic algorithm
    case automatic = "AUTOMATIC"
    
    /// Semi-automatic algorithm (with user interaction)
    case semiautomatic = "SEMIAUTOMATIC"
    
    /// Manual segmentation by user
    case manual = "MANUAL"
}

// MARK: - CIELabColor

/// CIELab color representation
///
/// Reference: PS3.3 C.10.7 - Display Shutter Module
public struct CIELabColor: Sendable, Hashable {
    /// L* - Lightness (0-65535)
    public let l: Int
    
    /// a* - Green-Red axis (-32768 to 32767, stored as 0-65535)
    public let a: Int
    
    /// b* - Blue-Yellow axis (-32768 to 32767, stored as 0-65535)
    public let b: Int
    
    /// Initialize a CIELab color
    public init(l: Int, a: Int, b: Int) {
        self.l = l
        self.a = a
        self.b = b
    }
}

// MARK: - ReferencedSeries

/// Referenced Series for Segmentation
///
/// Identifies the series that the segmentation is derived from.
public struct SegmentationReferencedSeries: Sendable, Hashable {
    /// Series Instance UID
    public let seriesInstanceUID: String
    
    /// Referenced Instance Sequence
    public let referencedInstances: [SegmentationReferencedInstance]
    
    /// Initialize a ReferencedSeries
    public init(
        seriesInstanceUID: String,
        referencedInstances: [SegmentationReferencedInstance] = []
    ) {
        self.seriesInstanceUID = seriesInstanceUID
        self.referencedInstances = referencedInstances
    }
}

// MARK: - ReferencedInstance

/// Referenced Instance for Segmentation
public struct SegmentationReferencedInstance: Sendable, Hashable {
    /// Referenced SOP Class UID
    public let sopClassUID: String
    
    /// Referenced SOP Instance UID
    public let sopInstanceUID: String
    
    /// Referenced Frame Numbers (for multi-frame images)
    public let referencedFrameNumbers: [Int]?
    
    /// Initialize a ReferencedInstance
    public init(
        sopClassUID: String,
        sopInstanceUID: String,
        referencedFrameNumbers: [Int]? = nil
    ) {
        self.sopClassUID = sopClassUID
        self.sopInstanceUID = sopInstanceUID
        self.referencedFrameNumbers = referencedFrameNumbers
    }
}

// MARK: - FunctionalGroup

/// Functional Group containing per-frame or shared attributes
///
/// Reference: PS3.3 C.7.6.16 - Multi-frame Functional Groups Module
public struct FunctionalGroup: Sendable {
    /// Segment Identification
    public let segmentIdentification: SegmentIdentification?
    
    /// Derivation Image
    public let derivationImage: DerivationImage?
    
    /// Frame Content
    public let frameContent: FrameContent?
    
    /// Plane Position
    public let planePosition: PlanePosition?
    
    /// Plane Orientation
    public let planeOrientation: PlaneOrientation?
    
    /// Initialize a FunctionalGroup
    public init(
        segmentIdentification: SegmentIdentification? = nil,
        derivationImage: DerivationImage? = nil,
        frameContent: FrameContent? = nil,
        planePosition: PlanePosition? = nil,
        planeOrientation: PlaneOrientation? = nil
    ) {
        self.segmentIdentification = segmentIdentification
        self.derivationImage = derivationImage
        self.frameContent = frameContent
        self.planePosition = planePosition
        self.planeOrientation = planeOrientation
    }
}

// MARK: - SegmentIdentification

/// Segment Identification Functional Group
///
/// Identifies which segment this frame represents.
///
/// Reference: PS3.3 C.8.20.2 - Segmentation Image Module
public struct SegmentIdentification: Sendable {
    /// Referenced Segment Number
    public let referencedSegmentNumber: Int
    
    /// Initialize a SegmentIdentification
    public init(referencedSegmentNumber: Int) {
        self.referencedSegmentNumber = referencedSegmentNumber
    }
}

// MARK: - DerivationImage

/// Derivation Image Functional Group
///
/// Describes how this frame was derived from source images.
///
/// Reference: PS3.3 C.7.6.16.2.3 - Derivation Image Functional Group Macro
public struct DerivationImage: Sendable {
    /// Source Image Sequence
    public let sourceImages: [SourceImage]
    
    /// Derivation Description
    public let derivationDescription: String?
    
    /// Derivation Code Sequence
    public let derivationCode: CodedConcept?
    
    /// Initialize a DerivationImage
    public init(
        sourceImages: [SourceImage],
        derivationDescription: String? = nil,
        derivationCode: CodedConcept? = nil
    ) {
        self.sourceImages = sourceImages
        self.derivationDescription = derivationDescription
        self.derivationCode = derivationCode
    }
}

// MARK: - SourceImage

/// Source Image reference
public struct SourceImage: Sendable {
    /// Referenced SOP Class UID
    public let sopClassUID: String
    
    /// Referenced SOP Instance UID
    public let sopInstanceUID: String
    
    /// Referenced Frame Number (for multi-frame source)
    public let referencedFrameNumber: Int?
    
    /// Purpose of Reference Code Sequence
    public let purposeOfReference: CodedConcept?
    
    /// Initialize a SourceImage
    public init(
        sopClassUID: String,
        sopInstanceUID: String,
        referencedFrameNumber: Int? = nil,
        purposeOfReference: CodedConcept? = nil
    ) {
        self.sopClassUID = sopClassUID
        self.sopInstanceUID = sopInstanceUID
        self.referencedFrameNumber = referencedFrameNumber
        self.purposeOfReference = purposeOfReference
    }
}

// MARK: - FrameContent

/// Frame Content Functional Group
///
/// Reference: PS3.3 C.7.6.16.2.2 - Frame Content Macro
public struct FrameContent: Sendable {
    /// Frame Acquisition Number
    public let frameAcquisitionNumber: Int?
    
    /// Frame Reference DateTime
    public let frameReferenceDateTime: String?
    
    /// Frame Acquisition DateTime
    public let frameAcquisitionDateTime: String?
    
    /// Dimension Index Values
    public let dimensionIndexValues: [Int]?
    
    /// Initialize a FrameContent
    public init(
        frameAcquisitionNumber: Int? = nil,
        frameReferenceDateTime: String? = nil,
        frameAcquisitionDateTime: String? = nil,
        dimensionIndexValues: [Int]? = nil
    ) {
        self.frameAcquisitionNumber = frameAcquisitionNumber
        self.frameReferenceDateTime = frameReferenceDateTime
        self.frameAcquisitionDateTime = frameAcquisitionDateTime
        self.dimensionIndexValues = dimensionIndexValues
    }
}

// MARK: - PlanePosition

/// Plane Position Functional Group
///
/// Reference: PS3.3 C.7.6.16.2.1 - Plane Position Macro
public struct PlanePosition: Sendable {
    /// Image Position (Patient) - x, y, z coordinates in mm
    public let imagePositionPatient: [Double]
    
    /// Initialize a PlanePosition
    public init(imagePositionPatient: [Double]) {
        self.imagePositionPatient = imagePositionPatient
    }
}

// MARK: - PlaneOrientation

/// Plane Orientation Functional Group
///
/// Reference: PS3.3 C.7.6.16.2.1 - Plane Orientation Macro
public struct PlaneOrientation: Sendable {
    /// Image Orientation (Patient) - 6 values defining row and column directions
    public let imageOrientationPatient: [Double]
    
    /// Initialize a PlaneOrientation
    public init(imageOrientationPatient: [Double]) {
        self.imageOrientationPatient = imageOrientationPatient
    }
}
